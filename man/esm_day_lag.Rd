% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{esm_day_lag}
\alias{esm_day_lag}
\title{Lag day-level (or wave-level, month-level, week-level) variables}
\usage{
esm_day_lag(data, variables, person_id, day_id)
}
\arguments{
\item{data}{The dataset to operate on.}

\item{variables}{The character vector of variables to lag}

\item{person_id}{The person level grouping variable - this should be your person id variable.}

\item{day_id}{The day level grouping variable - this should be your day id variable.}
}
\description{
This function will lag any variable at an aggregated level above the observation level (usually the day level).
It takes a dataset, a character vector of variables, and a character vector of grouping variables (by default the person and day ids), slices the first
value within each group, lags these, then merges the result back into the original dataframe. The result is that any aggregated variable (e.g. the daily mean
of a certain variable) will have all its (identical) values from one day applied as lagged variables to the following day, essentially as one would intuitively
expect.
}
\details{
Note that this function works with long data (i.e. expects one row per beep) though it may work with different formats, I wouldn't guarantee it. Could technically
be used to lag observation level variables if you added the beep id to the grouping vector, but no reason to use it in that fashion and I haven't tested it.

\code{\link{esm_lag}} and \code{\link{esm_day_lag}} are unique in that they output variables with the same appelation (_lag) because they output what we would expect
for lag at each level so this intuitively makes sense. The variables will already have names to say whether they're at the day level or not.
}
